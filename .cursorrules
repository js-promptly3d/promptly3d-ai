# Promptly3D Cursor Rules

Welcome to the master rules and standards file for Promptly3D. This document is your high-level guide to building, maintaining, and evolving a world-class, interactive 3D design platform. It is designed for both human developers and AI coding assistants.

## How to Use This File
- **For Developers:** Use this as your north star for architecture, code style, performance, and UX. For detailed, modular rules, see the `.cursor/rules/` directory.
- **For AI Assistants:** Reference this file for project-wide standards and philosophy. Use `.cursor/rules/` for granular, topic-specific rules.
- **For Everyone:** When in doubt, prioritize performance, accessibility, and user delight.

## Modular Rules System
- The `.cursor/rules/` directory contains focused, actionable rules on topics like 3D UX, animation, security, design systems, and more. Always check there for the latest best practices.
- For documentation, onboarding, and feature guides, see the `docs/` directory.

## Vibe Coding Philosophy
Promptly3D is built on the belief that creative coding should be fun, experimental, and visually stunning. We encourage "vibe coding":
- Embrace rapid prototyping and creative exploration.
- Use AI prompts and the prompt library to spark new ideas.
- Don’t be afraid to try wild animation or 3D effects—then refine for polish and performance.
- Share your best “hacks” and discoveries in the prompt library or docs.

## AI & Prompt-Driven Development
- Use the `docs/prompt-library.md` for inspiration and to document effective prompts and results.
- Leverage AI tools for code generation, refactoring, and creative brainstorming.
- When adding new features, consider writing a prompt first to clarify your intent.

## Core Principles

### Performance First
- Target 60 FPS on desktop, 30 FPS on mobile
- Optimize for WebGL performance and GPU memory usage
- Implement progressive loading and LOD systems
- Use efficient algorithms and data structures

### Progressive Enhancement
- Provide 2D fallbacks for 3D features when WebGL unavailable
- Implement graceful degradation for low-end devices
- Use feature detection over user agent sniffing
- Ensure core functionality works without JavaScript

### Accessibility
- Keyboard navigation for all 3D controls and interactions
- Screen reader support with meaningful object descriptions
- High contrast mode and colorblind-friendly palettes
- Voice commands and alternative input methods

### Mobile-First Design
- Touch gestures for 3D navigation and manipulation
- Responsive UI that works on all screen sizes
- Performance optimization for mobile GPUs
- Battery-conscious rendering and frame rate management

## Code Style and Architecture

### JavaScript ES6+ Standards
- Use const/let instead of var
- Implement classes for complex objects
- Use arrow functions for callbacks and short functions
- Implement proper error handling with try/catch

### Naming Conventions
- Classes: PascalCase (e.g., ModelViewer, TextToModel)
- Functions: camelCase (e.g., loadModel, generateMesh)
- Constants: UPPER_SNAKE_CASE (e.g., MAX_VERTICES, DEFAULT_QUALITY)
- Files: kebab-case (e.g., model-viewer.js, text-to-3d.js)

### Modular Architecture
- Separate concerns into focused modules
- Use dependency injection for better testability
- Implement clear interfaces between components
- Avoid global variables and state

### Memory Management
- Dispose of Three.js objects properly (geometry, materials, textures)
- Use object pooling for frequently created objects
- Implement garbage collection for unused assets
- Monitor memory usage and detect leaks

## 3D Development Patterns

### Scene Management
- Use single Three.js scene with modular components
- Implement efficient object hierarchy organization
- Use groups for logical object relationships
- Maintain consistent coordinate systems

### Geometry Optimization
- Use object pooling for frequently created geometries
- Implement geometry merging to reduce draw calls
- Use indexed geometries for vertex reuse
- Apply decimation algorithms for LOD generation

### Rendering Optimization
- Implement frustum culling for off-screen objects
- Use instanced rendering for repeated objects
- Batch draw calls where possible
- Optimize shader programs for mobile GPUs

### Asset Management
- Use GLTF/GLB format for 3D models
- Implement progressive asset loading
- Use texture atlasing and compression
- Cache assets efficiently with service workers

## WebGL Best Practices

### Context Handling
- Always check for WebGL context loss and implement recovery
- Use WebGL2 with graceful fallback to WebGL1
- Implement proper resource cleanup on context loss
- Monitor GPU memory usage and limits

### Shader Development
- Use precision qualifiers appropriately (mediump for mobile)
- Minimize texture lookups and branching
- Use efficient uniform and attribute layouts
- Implement fallback shaders for older devices

### Texture Management
- Use power-of-2 texture sizes when possible
- Implement texture compression (ETC1, ASTC, DXT)
- Use texture atlasing to reduce draw calls
- Implement mipmapping for distant objects

## User Experience Patterns

### Interaction Design
- Provide immediate visual feedback for all interactions
- Use consistent interaction patterns across the application
- Implement undo/redo for all operations
- Show loading states and progress indicators

### Error Handling
- Provide meaningful error messages to users
- Implement graceful fallbacks for failed operations
- Log errors for debugging while maintaining user experience
- Offer recovery options when possible

### Performance Feedback
- Show FPS and performance metrics in development
- Implement quality adjustment based on performance
- Provide manual quality controls for users
- Display loading progress for large assets

## Security and Privacy

### Input Validation
- Sanitize all user inputs, especially text-to-3D prompts
- Validate file uploads and model data
- Implement size limits for uploaded content
- Use Content Security Policy headers

### Data Protection
- Minimize data collection and storage
- Implement secure transmission for 3D models
- Follow GDPR and privacy regulations
- Provide clear data usage policies

## Testing and Quality Assurance

### Testing Strategy
- Unit tests for core 3D mathematics and utilities
- Integration tests for API endpoints
- Visual regression tests for 3D rendering
- Performance tests on various devices

### Code Quality
- Use ESLint and Prettier for consistent formatting
- Implement comprehensive JSDoc documentation
- Use TypeScript for type safety where beneficial
- Regular code reviews and refactoring

## Always Consider

### WebGL Compatibility
- Handle WebGL context loss gracefully
- Test on various GPU drivers and browsers
- Implement fallbacks for unsupported features
- Consider mobile GPU limitations and thermal throttling

### Network Conditions
- Optimize for slow network connections
- Implement efficient caching strategies
- Use progressive loading techniques
- Handle network failures gracefully

### Device Diversity
- Test on various screen sizes and orientations
- Consider different input methods (mouse, touch, keyboard)
- Optimize for different GPU capabilities
- Handle device-specific quirks and limitations

### Browser Compatibility
- Use WebGL2 with WebGL1 fallback
- Test across major browsers and versions
- Handle browser-specific bugs and limitations
- Use progressive enhancement principles

## Development Workflow

### Version Control
- Use descriptive commit messages
- Create feature branches for new functionality
- Implement pull request reviews
- Tag releases with version numbers

### Build Process
- Optimize assets during build time
- Implement code splitting for large applications
- Use tree shaking to remove unused code
- Generate source maps for debugging

### Deployment
- Use CDN for static assets
- Implement proper caching headers
- Use HTTPS for all communications
- Monitor application performance in production

## AI Integration Guidelines

### Text-to-3D Processing
- Implement robust parsing for natural language input
- Provide clear feedback for ambiguous requests
- Allow iterative refinement of generated models
- Cache common generations for performance

### Model Generation
- Validate generated models for manufacturing viability
- Implement quality checks and error correction
- Provide parameter adjustment interfaces
- Support various output formats (STL, OBJ, GLTF)

## Further Resources
- See `.cursor/rules/` for detailed rules on specific topics.
- See `docs/` for onboarding, feature documentation, design system, and prompt library.

Remember: This is a cutting-edge 3D web application. Always prioritize performance, user experience, and accessibility. The goal is to make 3D design accessible to everyone, regardless of their technical background or device capabilities.
